\chapter{Visualization Layer}\label{viz-ch}

The primary function of the visualization layer is to render a spectrogram
served by the compute layer. This module is also responsible for providing a
usable interface for an analyst to work with the datasets.  Minimizing latency
is an important design goal since increased latency can dramatically reduce an
analyst's efficiency if they must continually wait for the interface to respond
to queries. \\

We chose to build browser based visualizations to simplify the use for an
analyst -- the only software required is the browser itself. In addition, the
analyst does not require special hardware since the server handles the
intensive storage and computations. This choice makes the job of visualizing
interactively more difficult to design and implement since the browser is much
more limited in network bandwidth and rendering capabilities compared to a
native application.

\section{Design}

\subsection{Interface}

The interface should provide the analyst with the ability to specify a patient
\c{mrn} to query, a \c{start\_time} and \c{end\_time} and also afford quick
navigation between time ranges. The workflow that we anticipate is that an
analyst will load a single patient file and browse subsequent time windows. Upon
reaching a section of interest, the analyst should be able to zoom in to see
further details. The interface should also give the analyst information about
the visualization, such as interactive axes. The interface should also provide
user feedback for errors, validating data on the client to prevent the
inadvertent issuing of queries.

\subsection{Communication}

Optimizing communication is important to avoid creating a bottleneck that can
affect latency. The point which is most likely to be a bottleneck is
deserializing the data received from the network.

\subsection{Rendering}

The client rendering must be able to efficiently render large matrices of
floating point values, on the order of millions of points. The spectrogram
visualization is created by taking the intensity of the $(i, j)$-th entry in
the spectrogram and mapping it to a rendered color in the $(i, j)$-th pixel on
screen. Some amount of data aggregation is acceptable, for example
downsampling, however the analyst must not experience degradation of the
overall data quality. \\

\section{Implementation}

We implement the visualization layer primarily using HTML, JavaScript and CSS.
WebGL performs the spectrogram rendering to take advantage of a client's GPU.

\subsection{Interface}

Figure~\ref{fig:whole-interface} shows the implementation of the interface. The
interface shows a sample of a patient with \c{mrn} `\c{005}' rendered between
the second and third hour of the scan. These parameters are located in the top
bar, in addition to controls which enable the analyst to scroll to previous or
next hour with a single click. The scrolling interval defaults to 1 hour, but
is configurable in the settings window. \\

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.35]{./img/whole-interface.png}
\caption{Screenshot of Pinky's user interface. An analyst can view the four
  spectrograms corresponding to different regions of the brain and query for
  different time ranges to view.}
\label{fig:whole-interface}
\end{center}
\end{figure}

Clicking the small gear on the far right of the interface opens the
settings page, the available options are shown in Figure~\ref{fig:settings}.
The settings page allows an analyst to change the rendering mode, time interval
and select options for interpolation and the visualization scale. In addition,
there are two keyboard shortcuts which allow an analyst to change the amplitude
scale or zoom in on the visualization. Figure~\ref{fig:zoomed-region} shows the
result of a single region when a user has zoomed in. \\

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.35]{./img/settings.png}
\caption{Screenshot of the settings modal. The options allow an analyst to tune
  the visualization coloring and change the default time window query size.}
\label{fig:settings}
\end{center}
\end{figure}

The interface shows a spectrogram for each region of the brain, each region is
label in the upper left hand corner with \c{LL}, \c{LP}, \c{RP}, or \c{RL}.  As
Figure~\ref{fig:zoomed-region} shows, next to these labels, is a small box
containing axis information, specifying where the user's mouse currently is. In
this box the current timestamp (x-axis) and frequency (y-axis) are show. In
addition, the box shows the current amplitude value in decibels, dB, and the
current amplitude range. \\

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.35]{./img/zoomed-region.png}
\caption{Screenshot of a zoomed spectrogram view of a single rendered region
  with dynamic axis labels.}
\label{fig:zoomed-region}
\end{center}
\end{figure}

While loading, the interface blurs the spectrograms and presents a loading bar
to the user, as shown in Figure~\ref{fig:loading}. A delay between the
rendering of each region can cause confusion about the current rendered data.
Blurring a region and placing a loading bar on it distinguishes a region that
has not yet updated with the client's latest query results. \\

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.35]{./img/loading.png}
\caption{Screenshot of loading interface. When a new query is issued, the old
  data is blurred to avoid confusion of current and past results during query
  execution.}
\label{fig:loading}
\end{center}
\end{figure}

If an analyst enters an invalid \c{mrn}, the interface responds by clearing all
of the rendered spectrograms and displaying a small error message, shown in
Figure~\ref{fig:error}. An invalid \c{mrn} is simply one which the
\c{StorageBackend} does not contain an array for. This could be from a user slip
error or if the system is currently ingesting the array. This user interaction
is important to avoid analyst confusion when issuing an invalid query. \\

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.35]{./img/error.png}
\caption{Screenshot of invalid \c{mrn} error message when a bad query is
  issued.}
\label{fig:error}
\end{center}
\end{figure}

The CSS library Materialize \cite{materialize} was used to layout the page
structure and keep a consistent style throughout the webapp.

\subsection{Communication}

A websocket communicates with the compute layer websocket server using a binary
protocol described in Section~\ref{compute-ch:implementation-ws-server}. We
send requests as JSON encoded data and receive binary responses containing the
computed spectrogram data for a given region.

We make use of the reconnecting-websocket \cite{reconnecting-websocket} library
to ensure a smooth user experience if the analyst does not use the page and the
connection to closes. This library automatically reopens the connection,
instead of forcing the analyst to refresh the page altogether.

\subsection{Rendering}

WebGL is a JavaScript API which can render interactive 2D or 3D computer
graphics without the use of any third party plugins. The initial implementation
used the open-source library WebGL-Spectrogram \cite{webgl-spectrogram}. This
library has the functionality to render the spectrogram of an audio file using a
lightweight Python websocket server. We modified this library to a more general
version to contain multiple canvases, one for each brain region, and to
communicate with the compute layer websocket server. \\

\subsection{Optimizations}

WebGL was chosen since it is much more performant than using a browser's canvas
object or rendering DOM elements directly. Since each spectrogram is an array
on the order of millions of points, we would not be able to achieve the latency
required for interactivity without the GPU rendering. Development time suffers
from the use of WebGL since it is difficult to understand the programming model
without some background in graphics rendering. In addition, we use JavaScript
typed arrays to transfer the binary data from the websocket to the GPU.
JavaScript typed arrays are array-like objects providing access raw binary
data. JavaScript engines optimize these arrays giving higher performance than
the traditional JavaScript \c{Array} object.

